<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>技术 on 程序员的自我修养</title>
    <link>https://gdhucoder.github.io/categories/%E6%8A%80%E6%9C%AF/</link>
    <description>Recent content in 技术 on 程序员的自我修养</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cmn-Hans</language>
    <lastBuildDate>Mon, 11 Mar 2019 21:02:15 +0800</lastBuildDate>
    
	<atom:link href="https://gdhucoder.github.io/categories/%E6%8A%80%E6%9C%AF/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Go Basic</title>
      <link>https://gdhucoder.github.io/post/golang/04/</link>
      <pubDate>Mon, 11 Mar 2019 21:02:15 +0800</pubDate>
      
      <guid>https://gdhucoder.github.io/post/golang/04/</guid>
      <description>&lt;p&gt;[TOC]&lt;/p&gt;

&lt;p&gt;GO简单用法&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Go Programming Language</title>
      <link>https://gdhucoder.github.io/post/golang/01/</link>
      <pubDate>Sun, 10 Mar 2019 10:03:48 +0800</pubDate>
      
      <guid>https://gdhucoder.github.io/post/golang/01/</guid>
      <description>&lt;p&gt;[TOC]&lt;/p&gt;

&lt;p&gt;Go语言深入学习。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>读书笔记</title>
      <link>https://gdhucoder.github.io/post/golang/03/</link>
      <pubDate>Sat, 09 Mar 2019 23:39:02 +0800</pubDate>
      
      <guid>https://gdhucoder.github.io/post/golang/03/</guid>
      <description>&lt;p&gt;[TOC]&lt;/p&gt;

&lt;p&gt;读书笔记&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Golang not highlighting?</title>
      <link>https://gdhucoder.github.io/post/golang/02/</link>
      <pubDate>Sat, 09 Mar 2019 22:55:27 +0800</pubDate>
      
      <guid>https://gdhucoder.github.io/post/golang/02/</guid>
      <description>&lt;p&gt;[TOC]&lt;/p&gt;

&lt;p&gt;Golang not highlighting?&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>13 | 线性排序：如何根据年龄给100万用户数据排序？</title>
      <link>https://gdhucoder.github.io/post/alg4/geekbang/13/</link>
      <pubDate>Sat, 09 Mar 2019 08:53:01 +0800</pubDate>
      
      <guid>https://gdhucoder.github.io/post/alg4/geekbang/13/</guid>
      <description>&lt;p&gt;[TOC]&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://gitee.com/gdhu/prvpic/raw/master/2019-03-09-001.png&#34; alt=&#34;cover&#34; /&gt;&lt;/p&gt;

&lt;p&gt;本篇介绍线性时间排序。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>12 | 排序（下）：如何用快排思想在O(n)内查找第K大元素？</title>
      <link>https://gdhucoder.github.io/post/alg4/geekbang/12/</link>
      <pubDate>Wed, 06 Mar 2019 22:15:22 +0800</pubDate>
      
      <guid>https://gdhucoder.github.io/post/alg4/geekbang/12/</guid>
      <description>&lt;p&gt;[TOC]&lt;/p&gt;

&lt;p&gt;12 | 排序（下）：如何用快排思想在O(n)内查找第K大元素？&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://gitee.com/gdhu/prvpic/raw/master/2019-03-06-006.png&#34; alt=&#34;2019-03-06-006&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>11 | 排序（上）：为什么插入排序比冒泡排序更受欢迎？</title>
      <link>https://gdhucoder.github.io/post/alg4/geekbang/11/</link>
      <pubDate>Sat, 02 Mar 2019 19:31:55 +0800</pubDate>
      
      <guid>https://gdhucoder.github.io/post/alg4/geekbang/11/</guid>
      <description>&lt;p&gt;[TOC]&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://gitee.com/gdhu/prvpic/raw/master/2019-03-04-003.png&#34; alt=&#34;2019-03-04-003&#34; /&gt;&lt;/p&gt;

&lt;p&gt;本节主要介绍排序算法。&lt;/p&gt;

&lt;p&gt;首先思考一个问题：为什么插入排序比冒泡排序更受欢迎？&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>MarkDown内嵌标签</title>
      <link>https://gdhucoder.github.io/post/tech_details/markdown_use/</link>
      <pubDate>Sat, 02 Mar 2019 19:26:09 +0800</pubDate>
      
      <guid>https://gdhucoder.github.io/post/tech_details/markdown_use/</guid>
      <description>&lt;p&gt;[TOC]&lt;/p&gt;

&lt;p&gt;关于Markdown支持html标签&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>10 | 递归：如何用三行代码找到“最终推荐人”？</title>
      <link>https://gdhucoder.github.io/post/alg4/geekbang/10/</link>
      <pubDate>Sat, 02 Mar 2019 09:39:55 +0800</pubDate>
      
      <guid>https://gdhucoder.github.io/post/alg4/geekbang/10/</guid>
      <description>&lt;p&gt;[TOC]&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://gitee.com/gdhu/prvpic/raw/master/2019-03-02-003.png&#34; alt=&#34;2019-03-02-003&#34; /&gt;&lt;/p&gt;

&lt;p&gt;推荐注册返佣金这个功能一般来说不陌生吧？用户A推荐用户B来注册，用户B又推荐了用户C来注册。我们可以说C的“最终推荐人”为用户A，B的“最终推荐人”也为用户A，而用户A没有“最终推荐人”。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>用十年时间自学编程</title>
      <link>https://gdhucoder.github.io/post/timefriend/ten-years/</link>
      <pubDate>Sun, 17 Feb 2019 21:26:41 +0800</pubDate>
      
      <guid>https://gdhucoder.github.io/post/timefriend/ten-years/</guid>
      <description>&lt;p&gt;[TOC]&lt;/p&gt;

&lt;p&gt;业余时间翻译经典的博文。&lt;/p&gt;

&lt;p&gt;Teach yourself programming in ten years&lt;/p&gt;

&lt;p&gt;原文链接：&lt;a href=&#34;http://norvig.com/21-days.html&#34;&gt;ten years&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>04 | 复杂度分析（下）：浅析最好、最坏、平均、均摊时间复杂度</title>
      <link>https://gdhucoder.github.io/post/alg4/geekbang/04/</link>
      <pubDate>Sun, 03 Feb 2019 09:50:04 +0800</pubDate>
      
      <guid>https://gdhucoder.github.io/post/alg4/geekbang/04/</guid>
      <description>&lt;p&gt;[TOC]&lt;/p&gt;

&lt;p&gt;浅析最好、最坏、平均、均摊时间复杂度&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>String SortsSummary 字符串排序总结</title>
      <link>https://gdhucoder.github.io/post/alg4/chapter5/stringsortssummary/</link>
      <pubDate>Fri, 01 Feb 2019 13:32:20 +0800</pubDate>
      
      <guid>https://gdhucoder.github.io/post/alg4/chapter5/stringsortssummary/</guid>
      <description>&lt;p&gt;[TOC]&lt;/p&gt;

&lt;p&gt;整理字符串排序的知识点。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Problems</title>
      <link>https://gdhucoder.github.io/post/timefriend/2019-01-30/</link>
      <pubDate>Wed, 30 Jan 2019 21:08:33 +0800</pubDate>
      
      <guid>https://gdhucoder.github.io/post/timefriend/2019-01-30/</guid>
      <description>&lt;p&gt;[TOC]&lt;/p&gt;

&lt;p&gt;Today let&amp;rsquo;s talk about our problems.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>算法4 Java解答 5.1.2</title>
      <link>https://gdhucoder.github.io/post/alg4/chapter5/ex_5_1_02/</link>
      <pubDate>Thu, 24 Jan 2019 06:00:00 +0800</pubDate>
      
      <guid>https://gdhucoder.github.io/post/alg4/chapter5/ex_5_1_02/</guid>
      <description>5.1.2 问题： 给出使用地位优先的字符串排序算法处理下面这些键的轨迹
no is th ti fo al go pe to co to th ai of th pa
Give a trace for LSD string sort for the keys:
no is th ti fo al go pe to co to th ai of th pa
分析： LSD 适用于字符等长的数组排序。
从右往左，依次数组中每个元素对位置d的字符使用key-indexed counting排序。
平均数组访问次数7WN+3WR。额外空间N+R。 N 对应aux数组，R对应count数组。 对于一般的应用LSD线性时间复杂度。
public static void sort(String[] a, int w) { int N = a.length; int R = 256; String[] aux = new String[N]; for (int d = w - 1; d &amp;gt;= 0; d--) { // sort by key-indexed counting on dth char show(a); int[] count = new int[R + 1]; for (int i = 0; i &amp;lt; N; i++) { count[a[i].</description>
    </item>
    
    <item>
      <title>算法4 Java解答 2.4.24</title>
      <link>https://gdhucoder.github.io/post/alg4/chapter2/ex_2_4_24/</link>
      <pubDate>Sun, 04 Nov 2018 06:00:00 +0800</pubDate>
      
      <guid>https://gdhucoder.github.io/post/alg4/chapter2/ex_2_4_24/</guid>
      <description>2.4.24 问题： Priority queue with explicit links. Implement a priority queue using a heap- ordered binary tree, but use a triply linked structure instead of an array. You will need three links per node: two to traverse down the tree and one to traverse up the tree. Your implementation should guarantee logarithmic running time per operation, even if no maximum priority-queue size is known ahead of time.
使用链表的优先队列。使用二叉树实现一个优先队列。每个结点都需要三个链接：两个向下，一个向上。你的实现需要保证在无法预知队列大小的情况下也能保证优先队列的基本操作所需要的时间为对数级别。
分析： 插入\删除 ：</description>
    </item>
    
    <item>
      <title>算法4 Java解答 2.4.22</title>
      <link>https://gdhucoder.github.io/post/alg4/chapter2/ex_2_4_22/</link>
      <pubDate>Wed, 31 Oct 2018 08:00:00 +0800</pubDate>
      
      <guid>https://gdhucoder.github.io/post/alg4/chapter2/ex_2_4_22/</guid>
      <description>2.4.2 问题： 2.4.22 Array resizing. Add array resizing to MaxPQ, and prove bounds like those of Proposition Q for array accesses, in an amortized sense.
调整数组的大小。在MaxPQ中加入调整数组大小的代码，并和命题Q一样证明对于一般性长度为N的队列数组访问的上限。
分析： 在MaxHeap类中新增方法 resize(int max)，当堆的中元素个数等于key数组容量满的时候，key数组增大两倍，当堆的元素个数等于key数组长度的1/4时，key数组长度变为原来的1/2.
public _MaxMQ(){ this(1); } private void resize(int max){ assert max &amp;gt; N; Comparable[] temp = new Comparable[max]; for(int i=1; i&amp;lt;=N; i++){ temp[i] = pq[i]; } pq = (Key[]) temp; } public Key delMax(){ Key max = pq[1]; pq[1] = pq[N--]; // 使用 pq[N] 作为哨兵 sink(1); pq[N + 1] = null; if(N==(pq.</description>
    </item>
    
    <item>
      <title>算法4 Java解答 2.4.21</title>
      <link>https://gdhucoder.github.io/post/alg4/chapter2/ex_2_4_21/</link>
      <pubDate>Wed, 31 Oct 2018 06:00:00 +0800</pubDate>
      
      <guid>https://gdhucoder.github.io/post/alg4/chapter2/ex_2_4_21/</guid>
      <description>2.4.21 问题： 2.4.21 Elementary data structures. Explain how to use a priority queue to implement the stack, queue, and randomized queue data types from Chapter 1
分析： 题目要求使一个优先队列。
假设使用MaxPQ优先队列的操作有 insert delMax isEmpty size
Stack：
那么对于Stack LIFO 的实现我们需要指定被后插入的元素的priority比之前插入的元素priority大。
Queue:
对于Queue FIFO 的实现，需要后插入元素的priority小于之前插入元素的priority。
randomized queue：
随机队列需要指定一个随机的priority，其余实现和处理Queue的方法一样。
问题是怎么样生成一个不重复的随机数呢？我的思路是使用一个Set保存随机数。
public int random() { int num = 0; while (!numSet.contains(num)) { num = StdRandom.uniform(1, Integer.MAX_VALUE); numSet.add(num); break; } return num; }  另外要提到的是对于使用MaxPQ实现的Stack和Queue，插入删除元素的时间复杂度都是lgN。
class IKey implements Comparable&amp;lt;IKey&amp;gt;{ Key value; int priority; @Override public int compareTo(IKey another) { return compare(this.</description>
    </item>
    
    <item>
      <title>算法4 Java解答 2.4.20</title>
      <link>https://gdhucoder.github.io/post/alg4/chapter2/ex_2_4_20/</link>
      <pubDate>Mon, 29 Oct 2018 19:10:00 +0800</pubDate>
      
      <guid>https://gdhucoder.github.io/post/alg4/chapter2/ex_2_4_20/</guid>
      <description>2.4.20 问题： Prove that sink-based heap construction uses fewer than 2N compares and fewer than N exchanges.
证明基于下沉方法建立堆使用少于2N次的比较和N次交换。
分析： 官方网站解答：https://algs4.cs.princeton.edu/24pq/
假设为堆是完美的。
我们将树中节点的高度定义为以该节点为根的子树的高度。
一个高度为k的节点，下沉最多交换k次，对于每一层，有：
$$ \begin{eqnarray} h + 2(h-1) + 4(h-2) + 8(h-3) + \ldots + 2^h (0) &amp;amp; = &amp;amp; 2^{h+1} - h - 2 &amp;amp; = &amp;amp; n - (h+1) &amp;amp; \le &amp;amp; n \end{eqnarray} $$
第一项使用等比数列求和公式，第二项错位相减法。
参考： 沈星繁</description>
    </item>
    
    <item>
      <title>算法4 Java解答 2.4.19</title>
      <link>https://gdhucoder.github.io/post/alg4/chapter2/ex_2_4_19/</link>
      <pubDate>Sun, 28 Oct 2018 05:30:00 +0800</pubDate>
      
      <guid>https://gdhucoder.github.io/post/alg4/chapter2/ex_2_4_19/</guid>
      <description>2.4.19 问题： 2.4.19 Implement the constructor for MaxPQ that takes an array of items as argument, using the bottom-up heap construction method described on page 323 in the text.
实现一个MaxPQ的构造函数，接受一个数组做为参数，使用323页中描述的自底向上的方法构建堆。
分析： 将数组做为参数构建堆，可以选择从左到右扫描，使用swim()方法。 但更明智的方法是使用从右往左扫描的方式，sink()。 这个方法的想法是如果一个结点的两个子结点的树都是堆的话，sink(k)之后，两个子树就合并成了以k为根结点的子树
public MaxPQ(Key[] a){ N = a.length; pq = (Key[]) new Comparable[N+1]; for(int i=0; i&amp;lt;a.length; i++){ pq[i+1] = a[i]; } int k = N / 2; while (k &amp;gt;= 1){ sink(k); k --; } assert isMaxHeap(); show(); }  参考： 课本官网的实现MaxPQ</description>
    </item>
    
    <item>
      <title>算法4 Java解答 2.4.18</title>
      <link>https://gdhucoder.github.io/post/alg4/chapter2/ex_2_4_18/</link>
      <pubDate>Sat, 27 Oct 2018 06:00:00 +0800</pubDate>
      
      <guid>https://gdhucoder.github.io/post/alg4/chapter2/ex_2_4_18/</guid>
      <description>2.4.18 问题： 2.4.18 In MaxPQ, suppose that a client calls insert() with an item that is larger than all items in the queue, and then immediately calls delMax(). Assume that there are no duplicate keys. Is the resulting heap identical to the heap as it was before these op- erations? Answer the same question for two insert() operations (the first with a key larger than all keys in the queue and the second for a key larger than that one) followed by two delMax() operations.</description>
    </item>
    
    <item>
      <title>算法4习题 2.4.17</title>
      <link>https://gdhucoder.github.io/post/alg4/chapter2/ex_2_4_17/</link>
      <pubDate>Fri, 26 Oct 2018 06:00:00 +0800</pubDate>
      
      <guid>https://gdhucoder.github.io/post/alg4/chapter2/ex_2_4_17/</guid>
      <description>2.4.17 问题： 2.4.17 Prove that building a minimum-oriented priority queue of size k then doing N - k replace the minimum (insert followed by remove the minimum) operations leaves the k largest of the N items in the priority queue.
分析： 题意是insert followed by remove the minimum，先插入后删除。
例如
N=10, 元素为：0,2,4,6,8,1,3,5,7,9 k=3， qp = 0 2 4 N-k = 10 - 3 = 7，将要进行7次操作 pq = 0 2 4 count = 1 insert 6, pq = 0 2 4 6 remove 0, pq = 2 4 6 count = 2 insert 8, pq = 2 4 6 8 remove 2, pq = 4 6 8 count =3 insert 1, pq = 1 4 6 8 remove 1, pq = 4 6 8 .</description>
    </item>
    
    <item>
      <title>算法4习题 2.4.10</title>
      <link>https://gdhucoder.github.io/post/alg4/chapter2/ex_2_4_10/</link>
      <pubDate>Sat, 20 Oct 2018 08:00:00 +0800</pubDate>
      
      <guid>https://gdhucoder.github.io/post/alg4/chapter2/ex_2_4_10/</guid>
      <description> 2.4.10 问题： 2.4.10 Suppose that we wish to avoid wasting one position in a heap-ordered array pq[], putting the largest value in pq[0], its children in pq[1] and pq[2], and so forth, proceeding in level order. Where are the parents and children of pq[k]?
分析： 略
答案： 子节点：$ 2k+1, 2k+2 $，父节点： $ \lfloor \frac{k-1}{2} \rfloor $
参考： </description>
    </item>
    
    <item>
      <title>2018-10-19 解决Markdown图片问题</title>
      <link>https://gdhucoder.github.io/post/skill/2018-10-19/</link>
      <pubDate>Fri, 19 Oct 2018 03:00:00 +0800</pubDate>
      
      <guid>https://gdhucoder.github.io/post/skill/2018-10-19/</guid>
      <description>[TOC]
里程碑 今天是一个里程碑，断断续续一年多，自己搭建的博客遇到的各种问题基本得到解决。
现在整理一下解决问题的思路：
博客用到的东西：Github(托管静态网页)、Hugo、Sublime、Markdown、MathJax、免费图床(gitee)、留言(需要翻墙)
遇到的问题主要有： 图床问题： 使用免费图床是个大问题：目前的解决方案是将图片上床到gitee上，这样国内访问图片速度较快。
图片链接插入问题： 之前我写了自动生成链接的脚本，但是结果输出到了文本文件中，对于图片预览实时性的要求就无法满足。
平台不通用问题： 通用性的问题一直没有解决：对于Latex公式的支持，图床的支持
以前由于各个平台不通用的问题，导致我们一直只能在一个平台上写作。而各大平台又各有优缺点，总有令人不满意的地方。
这样下来在本地写的Markdown，不需要做修改可以支持CSDN博客（或者简书）了，直接复制过去就可以。
在未来不久印象笔记windows版本也会支持Markdown，真是个令人振奋的消息。
甚至我还使用过马克飞象，但是它只能配合印象笔记使用，对于跨平台的需求无法满足。
我的github 页面托管到了github上，有兴趣的话可以试着自己搭建一个静态博客。
https://gdhucoder.github.io/
图片本地预览、链接 大家都知道Markdown使用图片需要插入图片链接。
我们使用python写了个脚本，生成文件的缩略图，自动上传gitee，点击图片缩略图，获取链接到剪切板。
接下来我又添加的每次打开Helper时，自动提交git，得到最新的图片
然后点击图片缩略图，图片的git地址（可供外网访问的地址）就被拷贝到了剪切板中，在使用的时候我们直接Ctrl+V就可以复制地址到Markdown文档中。
这个脚本还支持子目录的打开预览。
因为如果我们只用一个文件夹管理所有的博客图片势必会没有层级结构，导致最后图片混乱。
我们可以建立子文件夹，存放各个主题的图片文件。
Picture Helper使用方法：  upload your pictures to github or gitee this script can generate latest 100 picture links click the thumb picture, then the link is clipped into you clipboard then use Ctrl+V in your own Markdown Enjoy!  另附代码 主要参考了PP4E的pyphoto的代码。
各位改改可以用到的地方： 1、自动提交git脚本 2、生成缩略图（PIL的使用）</description>
    </item>
    
    <item>
      <title>算法4习题 2.1.12</title>
      <link>https://gdhucoder.github.io/post/alg4/chapter2/chapter2-1-12/</link>
      <pubDate>Mon, 06 Aug 2018 08:00:00 +0800</pubDate>
      
      <guid>https://gdhucoder.github.io/post/alg4/chapter2/chapter2-1-12/</guid>
      <description>算法4习题 2.1.12 问题 Instrument shellsort to print the number of compares divided by the array size for each increment. Write a test client that tests the hypothesis that this number is a small constant, by sorting arrays of random Double values, using array sizes that are increasing powers of 10, starting at 100.
打印希尔排序中每个增量带来的比较次数和数组大小的比值。 验证该值是一个小常数。
思路 统计每个增量对应的比较次数。
private static boolean less(Comparable v, Comparable w) { count ++ ; return v.</description>
    </item>
    
    <item>
      <title>算法4 chp 1-1</title>
      <link>https://gdhucoder.github.io/post/alg4/chapter1/chapter1-1/</link>
      <pubDate>Tue, 15 May 2018 08:00:00 +0800</pubDate>
      
      <guid>https://gdhucoder.github.io/post/alg4/chapter1/chapter1-1/</guid>
      <description>1.1.1 7, 200.0000002, true
1.1.2 a. double 1.618 b. double 10.0 c. boolean true d. String &amp;ldquo;33&amp;rdquo;
执行Java 采用输入命令的形式：
目录：
E:\GDUT\Dropbox\Alg4\algs4\target\classes
执行：
java edu.princeton.cs.myalg.u1.Ex_1_1_3 1 1 2
$ab=bc$ $$ab=cd$$ [ x = {-b \pm \sqrt{b^2-4ac} \over 2a} \]</description>
    </item>
    
    <item>
      <title>java问题</title>
      <link>https://gdhucoder.github.io/post/note/2018-05-15/</link>
      <pubDate>Tue, 15 May 2018 07:00:00 +0800</pubDate>
      
      <guid>https://gdhucoder.github.io/post/note/2018-05-15/</guid>
      <description>&lt;p&gt;[TOC]&lt;/p&gt;

&lt;p&gt;学习过程中遇到的一些技术问题。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>java问题</title>
      <link>https://gdhucoder.github.io/post/note/2018-05-10-note/</link>
      <pubDate>Mon, 14 May 2018 07:00:00 +0800</pubDate>
      
      <guid>https://gdhucoder.github.io/post/note/2018-05-10-note/</guid>
      <description>&lt;p&gt;[TOC]&lt;/p&gt;

&lt;p&gt;学习过程中遇到的一些技术问题。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Optimistic Initial Values</title>
      <link>https://gdhucoder.github.io/post/note/2018-04-06-rl-note/</link>
      <pubDate>Fri, 06 Apr 2018 07:00:00 +0800</pubDate>
      
      <guid>https://gdhucoder.github.io/post/note/2018-04-06-rl-note/</guid>
      <description>&lt;p&gt;[TOC]&lt;/p&gt;

&lt;p&gt;Multi-armed Bandits 本篇主要介绍多臂赌博机问题的相关算法。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>MarkDown Preview MathJax</title>
      <link>https://gdhucoder.github.io/post/note/markdown-preview-mathjax/</link>
      <pubDate>Thu, 05 Apr 2018 07:00:00 +0800</pubDate>
      
      <guid>https://gdhucoder.github.io/post/note/markdown-preview-mathjax/</guid>
      <description>&lt;p&gt;[TOC]&lt;/p&gt;

&lt;h1 id=&#34;关于markdown中的公式&#34;&gt;关于MarkDown中的公式&lt;/h1&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>如何使用gitee作为免费图床</title>
      <link>https://gdhucoder.github.io/post/tech_details/gitee_as_pic_storage/</link>
      <pubDate>Wed, 04 Apr 2018 21:25:07 +0800</pubDate>
      
      <guid>https://gdhucoder.github.io/post/tech_details/gitee_as_pic_storage/</guid>
      <description>&lt;p&gt;[TOC]&lt;/p&gt;

&lt;p&gt;本篇文章是一个启发，介绍如何使用gitee作为免费图床。
没有使用github的原因是github国内访问有些慢。
另外，还有其他优秀的云存储，例如7niu，朋友们也可以试一下。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>HuGo中文章加入目录</title>
      <link>https://gdhucoder.github.io/post/note/how-to-add-table-of-contents-in-hugo/</link>
      <pubDate>Wed, 04 Apr 2018 09:00:00 +0800</pubDate>
      
      <guid>https://gdhucoder.github.io/post/note/how-to-add-table-of-contents-in-hugo/</guid>
      <description>&lt;p&gt;本文介绍如何在template中加入TOC目录。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>规划中的宏动作</title>
      <link>https://gdhucoder.github.io/post/note/2018-04-04/</link>
      <pubDate>Tue, 03 Apr 2018 21:00:00 +0800</pubDate>
      
      <guid>https://gdhucoder.github.io/post/note/2018-04-04/</guid>
      <description>&lt;p&gt;本文介绍如何在经典规划中的宏动作。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>废弃不用的链接</title>
      <link>https://gdhucoder.github.io/post/note/2018-03-29/</link>
      <pubDate>Thu, 29 Mar 2018 21:00:00 +0800</pubDate>
      
      <guid>https://gdhucoder.github.io/post/note/2018-03-29/</guid>
      <description>废弃不用的链接 https://my.oschina.net/leonhu/blog
http://gdhu.oschina.io/blog/
https://git.oschina.net/gdhu</description>
    </item>
    
    <item>
      <title>基于试验的启发式树搜索</title>
      <link>https://gdhucoder.github.io/post/note/2018-01-05/</link>
      <pubDate>Thu, 04 Jan 2018 21:25:07 +0800</pubDate>
      
      <guid>https://gdhucoder.github.io/post/note/2018-01-05/</guid>
      <description>&lt;p&gt;[TOC]&lt;/p&gt;

&lt;h3 id=&#34;概念&#34;&gt;概念&lt;/h3&gt;

&lt;p&gt;给定一个MDP，一个agent可以访问：&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>什么是蒙特卡罗</title>
      <link>https://gdhucoder.github.io/post/planning/montecarlo/monte_carlo/</link>
      <pubDate>Sun, 26 Nov 2017 21:25:07 +0800</pubDate>
      
      <guid>https://gdhucoder.github.io/post/planning/montecarlo/monte_carlo/</guid>
      <description>&lt;p&gt;[TOC]&lt;/p&gt;

&lt;p&gt;乍一听“蒙特卡罗”这个词，完全不知所云，我感到很奇怪，一个搜索算法Monte Carlo Tree Search为什么叫蒙特卡罗。
于是，就有了下面的文字。&lt;/p&gt;

&lt;p&gt;本篇文章主要介绍MonteCarlo方法的由来，及简单的一个应用-求π的值。
下篇将会介绍：什么是Monte Carlo Tree Search算法。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Heuristic Search之Greedy Best First Search</title>
      <link>https://gdhucoder.github.io/post/java_skill/20171025-heuristic_search_gbfs/</link>
      <pubDate>Wed, 25 Oct 2017 21:25:07 +0800</pubDate>
      
      <guid>https://gdhucoder.github.io/post/java_skill/20171025-heuristic_search_gbfs/</guid>
      <description>&lt;p&gt;[TOC]&lt;/p&gt;

&lt;p&gt;本篇文章介绍Greedy Best Fisrt Search算法。实现GBFS算法时使用了上篇文章介绍的优先队列。
下篇文章将尝试介绍著名的A star算法。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Priority Queues</title>
      <link>https://gdhucoder.github.io/post/java_skill/20171024-priority_queue/</link>
      <pubDate>Tue, 24 Oct 2017 21:25:07 +0800</pubDate>
      
      <guid>https://gdhucoder.github.io/post/java_skill/20171024-priority_queue/</guid>
      <description>&lt;p&gt;[TOC]&lt;/p&gt;

&lt;p&gt;本篇文章主要介绍优先队列(Priority Queue)和嵌套类(nested class)的基本用法。
接下来的文章会介绍在实现例如Greedy Best First Search和AStar搜索算法中使用priority queue。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>贝叶斯引论（一）</title>
      <link>https://gdhucoder.github.io/post/planning/pln_1/pln_1/</link>
      <pubDate>Fri, 20 Oct 2017 21:25:07 +0800</pubDate>
      
      <guid>https://gdhucoder.github.io/post/planning/pln_1/pln_1/</guid>
      <description>&lt;p&gt;[TOC]&lt;/p&gt;

&lt;p&gt;本篇开始，逐一介绍一些概率编程相关内容。首先介绍贝叶斯网的相关基础知识和应用。&lt;/p&gt;

&lt;p&gt;本篇导读：&lt;/p&gt;

&lt;p&gt;本篇主要介绍了贝叶斯定理，贝叶斯网以及相关应用：&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>matplot的使用之四:细节设置(2/2)</title>
      <link>https://gdhucoder.github.io/post/plt_5/plt_5/</link>
      <pubDate>Wed, 09 Aug 2017 21:44:30 +0800</pubDate>
      
      <guid>https://gdhucoder.github.io/post/plt_5/plt_5/</guid>
      <description>&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;#Color
import pandas as pd
import matplotlib.pyplot as plt

women_degrees = pd.read_csv(&#39;percent-bachelors-degrees-women-usa.csv&#39;)
major_cats = [&#39;Biology&#39;, &#39;Computer Science&#39;, &#39;Engineering&#39;, &#39;Math and Statistics&#39;]</description>
    </item>
    
    <item>
      <title>matplot的使用之四:细节设置(1/2)</title>
      <link>https://gdhucoder.github.io/post/plt_4/plt_4/</link>
      <pubDate>Wed, 09 Aug 2017 20:44:30 +0800</pubDate>
      
      <guid>https://gdhucoder.github.io/post/plt_4/plt_4/</guid>
      <description>&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import pandas as pd
import matplotlib.pyplot as plt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>matplot的使用之三:直方图、盒形图</title>
      <link>https://gdhucoder.github.io/post/plt_3/plt_3/</link>
      <pubDate>Wed, 09 Aug 2017 19:44:30 +0800</pubDate>
      
      <guid>https://gdhucoder.github.io/post/plt_3/plt_3/</guid>
      <description>&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import pandas as pd
import matplotlib.pyplot as plt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>matplot的使用之二:柱状图、散点图</title>
      <link>https://gdhucoder.github.io/post/plt_2/plt_2/</link>
      <pubDate>Tue, 08 Aug 2017 21:44:30 +0800</pubDate>
      
      <guid>https://gdhucoder.github.io/post/plt_2/plt_2/</guid>
      <description>&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import pandas as pd
reviews = pd.read_csv(&#39;fandango_scores.csv&#39;)
cols = [&#39;FILM&#39;, &#39;RT_user_norm&#39;, &#39;Metacritic_user_nom&#39;, &#39;IMDB_norm&#39;, &#39;Fandango_Ratingvalue&#39;, &#39;Fandango_Stars&#39;]
norm_reviews = reviews[cols]
print(norm_reviews[:1])
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>matplot的使用之一:折线图、子图</title>
      <link>https://gdhucoder.github.io/post/plt_1/plt_1/</link>
      <pubDate>Thu, 03 Aug 2017 21:44:30 +0800</pubDate>
      
      <guid>https://gdhucoder.github.io/post/plt_1/plt_1/</guid>
      <description>&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import pandas as pd
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;unrate = pd.read_csv(&#39;UNRATE.csv&#39;)
unrate[&#39;DATE&#39;] = pd.to_datetime(unrate[&#39;DATE&#39;])
print(unrate.head(12))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>