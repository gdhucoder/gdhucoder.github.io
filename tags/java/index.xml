<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Java on 野生程序员</title>
    <link>https://gdhucoder.github.io/tags/java/</link>
    <description>Recent content in Java on 野生程序员</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cmn-Hans</language>
    <lastBuildDate>Mon, 29 Oct 2018 19:10:00 +0800</lastBuildDate>
    
	<atom:link href="https://gdhucoder.github.io/tags/java/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>算法4 Java解答 2.4.20</title>
      <link>https://gdhucoder.github.io/post/alg4/chapter2/ex_2_4_20/</link>
      <pubDate>Mon, 29 Oct 2018 19:10:00 +0800</pubDate>
      
      <guid>https://gdhucoder.github.io/post/alg4/chapter2/ex_2_4_20/</guid>
      <description>2.4.20 问题： Prove that sink-based heap construction uses fewer than 2N compares and fewer than N exchanges.
证明基于下沉方法建立堆使用少于2N次的比较和N次交换。
分析： 官方网站解答：https://algs4.cs.princeton.edu/24pq/
假设为堆是完美的。
我们将树中节点的高度定义为以该节点为根的子树的高度。
一个高度为k的节点，下沉最多交换k次，对于每一层，有：
$$ \begin{eqnarray} h + 2(h-1) + 4(h-2) + 8(h-3) + \ldots + 2^h (0) &amp;amp; = &amp;amp; 2^{h+1} - h - 2 &amp;amp; = &amp;amp; n - (h+1) &amp;amp; \le &amp;amp; n \end{eqnarray} $$
第一项使用等比数列求和公式，第二项错位相减法。
参考： 沈星繁</description>
    </item>
    
    <item>
      <title>算法4 Java解答 2.4.19</title>
      <link>https://gdhucoder.github.io/post/alg4/chapter2/ex_2_4_19/</link>
      <pubDate>Sun, 28 Oct 2018 05:30:00 +0800</pubDate>
      
      <guid>https://gdhucoder.github.io/post/alg4/chapter2/ex_2_4_19/</guid>
      <description>2.4.19 问题： 2.4.19 Implement the constructor for MaxPQ that takes an array of items as argument, using the bottom-up heap construction method described on page 323 in the text.
实现一个MaxPQ的构造函数，接受一个数组做为参数，使用323页中描述的自底向上的方法构建堆。
分析： 将数组做为参数构建堆，可以选择从左到右扫描，使用swim()方法。 但更明智的方法是使用从右往左扫描的方式，sink()。 这个方法的想法是如果一个结点的两个子结点的树都是堆的话，sink(k)之后，两个子树就合并成了以k为根结点的子树
public MaxPQ(Key[] a){ N = a.length; pq = (Key[]) new Comparable[N+1]; for(int i=0; i&amp;lt;a.length; i++){ pq[i+1] = a[i]; } int k = N / 2; while (k &amp;gt;= 1){ sink(k); k --; } assert isMaxHeap(); show(); }  参考： 课本官网的实现MaxPQ</description>
    </item>
    
    <item>
      <title>算法4 Java解答 2.4.18</title>
      <link>https://gdhucoder.github.io/post/alg4/chapter2/ex_2_4_18/</link>
      <pubDate>Sat, 27 Oct 2018 06:00:00 +0800</pubDate>
      
      <guid>https://gdhucoder.github.io/post/alg4/chapter2/ex_2_4_18/</guid>
      <description>2.4.18 问题： 2.4.18 In MaxPQ, suppose that a client calls insert() with an item that is larger than all items in the queue, and then immediately calls delMax(). Assume that there are no duplicate keys. Is the resulting heap identical to the heap as it was before these op- erations? Answer the same question for two insert() operations (the first with a key larger than all keys in the queue and the second for a key larger than that one) followed by two delMax() operations.</description>
    </item>
    
    <item>
      <title>算法4习题 2.4.17</title>
      <link>https://gdhucoder.github.io/post/alg4/chapter2/ex_2_4_17/</link>
      <pubDate>Fri, 26 Oct 2018 06:00:00 +0800</pubDate>
      
      <guid>https://gdhucoder.github.io/post/alg4/chapter2/ex_2_4_17/</guid>
      <description>2.4.17 问题： 2.4.17 Prove that building a minimum-oriented priority queue of size k then doing N - k replace the minimum (insert followed by remove the minimum) operations leaves the k largest of the N items in the priority queue.
分析： 题意是insert followed by remove the minimum，先插入后删除。
例如
N=10, 元素为：0,2,4,6,8,1,3,5,7,9 k=3， qp = 0 2 4 N-k = 10 - 3 = 7，将要进行7次操作 pq = 0 2 4 count = 1 insert 6, pq = 0 2 4 6 remove 0, pq = 2 4 6 count = 2 insert 8, pq = 2 4 6 8 remove 2, pq = 4 6 8 count =3 insert 1, pq = 1 4 6 8 remove 1, pq = 4 6 8 .</description>
    </item>
    
    <item>
      <title>算法4习题 2.4.10</title>
      <link>https://gdhucoder.github.io/post/alg4/chapter2/ex_2_4_10/</link>
      <pubDate>Sat, 20 Oct 2018 08:00:00 +0800</pubDate>
      
      <guid>https://gdhucoder.github.io/post/alg4/chapter2/ex_2_4_10/</guid>
      <description> 2.4.10 问题： 2.4.10 Suppose that we wish to avoid wasting one position in a heap-ordered array pq[], putting the largest value in pq[0], its children in pq[1] and pq[2], and so forth, proceeding in level order. Where are the parents and children of pq[k]?
分析： 略
答案： 子节点：$ 2k+1, 2k+2 $，父节点： $ \lfloor \frac{k-1}{2} \rfloor $
参考： </description>
    </item>
    
    <item>
      <title>算法4习题 2.1.12</title>
      <link>https://gdhucoder.github.io/post/alg4/chapter2/chapter2-1-12/</link>
      <pubDate>Mon, 06 Aug 2018 08:00:00 +0800</pubDate>
      
      <guid>https://gdhucoder.github.io/post/alg4/chapter2/chapter2-1-12/</guid>
      <description>算法4习题 2.1.12 问题 Instrument shellsort to print the number of compares divided by the array size for each increment. Write a test client that tests the hypothesis that this number is a small constant, by sorting arrays of random Double values, using array sizes that are increasing powers of 10, starting at 100.
打印希尔排序中每个增量带来的比较次数和数组大小的比值。 验证该值是一个小常数。
思路 统计每个增量对应的比较次数。
private static boolean less(Comparable v, Comparable w) { count ++ ; return v.</description>
    </item>
    
    <item>
      <title>算法4 chp 1-1</title>
      <link>https://gdhucoder.github.io/post/alg4/chapter1/chapter1-1/</link>
      <pubDate>Tue, 15 May 2018 08:00:00 +0800</pubDate>
      
      <guid>https://gdhucoder.github.io/post/alg4/chapter1/chapter1-1/</guid>
      <description>1.1.1 7, 200.0000002, true
1.1.2 a. double 1.618 b. double 10.0 c. boolean true d. String &amp;ldquo;33&amp;rdquo;
执行Java 采用输入命令的形式：
目录：
E:\GDUT\Dropbox\Alg4\algs4\target\classes
执行：
java edu.princeton.cs.myalg.u1.Ex_1_1_3 1 1 2
$ab=bc$ $$ab=cd$$ [ x = {-b \pm \sqrt{b^2-4ac} \over 2a} \]</description>
    </item>
    
    <item>
      <title>java问题</title>
      <link>https://gdhucoder.github.io/post/note/2018-05-15/</link>
      <pubDate>Tue, 15 May 2018 07:00:00 +0800</pubDate>
      
      <guid>https://gdhucoder.github.io/post/note/2018-05-15/</guid>
      <description>&lt;p&gt;[TOC]&lt;/p&gt;

&lt;p&gt;学习过程中遇到的一些技术问题。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Priority Queues</title>
      <link>https://gdhucoder.github.io/post/java_skill/20171024-priority_queue/</link>
      <pubDate>Tue, 24 Oct 2017 21:25:07 +0800</pubDate>
      
      <guid>https://gdhucoder.github.io/post/java_skill/20171024-priority_queue/</guid>
      <description>&lt;p&gt;[TOC]&lt;/p&gt;

&lt;p&gt;本篇文章主要介绍优先队列(Priority Queue)和嵌套类(nested class)的基本用法。
接下来的文章会介绍在实现例如Greedy Best First Search和AStar搜索算法中使用priority queue。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>